<html>
	<head>
		<title>Polygon</title>
		<style>canvas { width: 100%; height: 100% }</style>
	</head>
	<body>
		<!-- Laddar in three.js -->
		<script src="https://rawgithub.com/mrdoob/three.js/master/build/three.js"></script>

		<!-- Laddar in tween-biblioteket -->
		<script type='text/javascript' src='./js/tween.min.js'></script>
		<!-- Laddar in styrningen -->
		<script src="./js/FirstPersonControls.js"></script>
		<!-- Laddar in så det enkelt går att spela musik -->
		<script src="./js/AudioObject.js"></script>
		<script src="./js/ParticleEngine.js"></script>
		<script src="./js/Stats.js"></script>

		<script>
			var camera, scene, stats, renderer, planets, controls, clock, cube;
	  
	  	//Anropar funktioner för att bygga världen samt Three.js-inställningnarna, för att sedan rendera
	  	function setup() {
		    setupThreeJS();
		    setupStats();
		    setupWorld();
		    setupTween();
		}; 

		function animation(){
			requestAnimationFrame(function animate() {
				
				var timer = 0.0001 * Date.now();

		     	for ( var i = 0, l = objects.length; i < l; i ++ ) {

					var object = objects[i];
					//Var 30:onde blir bouncy
					if(i % 30 == 0)
					{
						object.scale.x = Math.pow(Math.sin(timer * 20), 2) + 0.95;
						object.scale.y = object.scale.x;
						object.scale.z = object.scale.x;
					}
					else 
					{	
						object.rotation.x += Math.random()*0.01;
						object.rotation.y += 0.01;
					}
							
				}

				
			var test = objects[100];
			test.rotation.x = 0;
			test.rotation.y = 0;

			test.position.x = Math.cos( timer * 4 ) * 100;
			test.position.y = Math.sin( timer * 8 ) * 100;
			test.position.z = 10;

	     	particleLight.position.x = Math.sin( timer * 7 ) * 1000;
			particleLight.position.y = Math.cos( timer * 5 ) * 1000;
			particleLight.position.z = Math.cos( timer * 3 ) * 1000;

			pointLight.position.x = particleLight.position.x;
			pointLight.position.y = particleLight.position.y;
			pointLight.position.z = particleLight.position.z;

			render();
			update();

     		requestAnimationFrame(animate);
			});
	 	}

	 	function render() {
	 		renderer.render(scene, camera);
	 	}

	 	function update(){
	 		//Particle field update variables
			//var dt = clock.getDelta();
			//engine.update( dt * 0.5 );

			stats.update();
	 		controls.update(clock.getDelta());
     		TWEEN.update();
	 	}

	  	 //Sätter inställningnarna för three.js
	   	function setupThreeJS() {
			scene = new THREE.Scene();
			
			camera = new THREE.PerspectiveCamera(45, window.innerWidth /
			window.innerHeight, 1, 10000);
			camera.position.y = 10;
 			camera.position.z = 100;

			//Renderar i WebGL om webläsaren stödjer det
			if (window.WebGLRenderingContext)
				renderer = new THREE.WebGLRenderer();
			else
				renderer = new THREE.CanvasRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			//Används för styrningen, som i detta fall är FirstPersonControls
			clock = new THREE.Clock();
			controls = new THREE.FirstPersonControls(camera);
			controls.movementSpeed = 100;
			controls.lookSpeed = 0.1;
		}

		function setupStats(){
			stats = new Stats();

 			stats.setMode(0); // 0: fps, 1: ms

			// Align top-left
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.left = '0px';
			stats.domElement.style.top = '0px';

			document.body.appendChild( stats.domElement );
		}

	   	//Definerar världen och objekt som finns i den
	   	function setupWorld() {

	   		//Skybox
	   		//Laddar in sex bilder och applicerar som textur på 5000x5000x5000-kub
	   		var imagePrefix = "skybox/space-";
			var directions  = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
			var imageSuffix = ".jpg";
			var skyGeometry = new THREE.BoxGeometry( 5000, 5000, 5000 );	
			 
			var skyMaterialArray = [];
			for (var i = 0; i < 6; i++)
				skyMaterialArray.push( new THREE.MeshBasicMaterial({
					map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
					side: THREE.BackSide
				}));
			var skyMaterial = new THREE.MeshFaceMaterial( skyMaterialArray );
			var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
			scene.add( skyBox );

			//Particle field
			/*this.engine = new ParticleEngine();

			//Particle field parameters
			parameters =
				{
					positionStyle    : Type.CUBE,
					positionBase     : new THREE.Vector3( 0, 200, 0 ),
					positionSpread   : new THREE.Vector3( 600, 400, 600 ),

					velocityStyle    : Type.CUBE,
					velocityBase     : new THREE.Vector3( 0, 0, 0 ),
					velocitySpread   : new THREE.Vector3( 0.5, 0.5, 0.5 ), 
					
					angleBase               : 0,
					angleSpread             : 720,
					angleVelocityBase       : 0,
					angleVelocitySpread     : 4,

					particleTexture : THREE.ImageUtils.loadTexture( 'images/spikey.png' ),
					
					sizeBase    : 10.0,
					sizeSpread  : 2.0,				
					colorBase   : new THREE.Vector3(0.15, 1.0, 0.9), // H,S,L
					colorSpread : new THREE.Vector3(0.00, 0.0, 0.2),
					opacityBase : 1,

					particlesPerSecond : 20000,
					particleDeathAge   : 60.0,		
					emitterDeathAge    : 0.1
				},

			engine.setValues( parameters );
			engine.initialize();*/

			//Dimma
			//scene.fog = new THREE.Fog( 0xffffff, 0.01, 6000 );

			//Array med de olika materialen som sfärerna kan få
			var materials = [];
			materials.push(new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff, shading: THREE.FlatShading}));
			materials.push(new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff, shading: THREE.FlatShading}));
			materials.push(new THREE.MeshBasicMaterial({color: Math.random() * 0xffffff, wireframe: true}));
			materials.push(new THREE.MeshBasicMaterial({color: Math.random() * 0xffffff, wireframe: true}));
			materials.push(new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff, transparent: true, shading: THREE.FlatShading}));
			materials.push( new THREE.MeshPhongMaterial( { ambient: 0x030303, color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.FlatShading } ) );
			materials.push(new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff, shading: THREE.FlatShading}));
			materials.push(new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff, shading: THREE.FlatShading}));
			materials.push(new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff, shading: THREE.FlatShading}));
			materials.push(new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff, shading: THREE.FlatShading}));
			materials.push(new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff, shading: THREE.FlatShading}));

			 
			//geometrin som används då materialet är facematerial
			var geometry_pieces = new THREE.SphereGeometry( 25, 32, 16 ); 

				for ( var i = 0, l = geometry_pieces.faces.length; i < l; i ++ ) {

					var face = geometry_pieces.faces[ i ];
					face.materialIndex = Math.floor( Math.random() * materials.length );

				}

				geometry_pieces.materials = materials;
			
			materials.push( new THREE.MeshFaceMaterial( materials ) );


			objects = [];

		    for (var i = 0; i < 1000; i++) {

			    var planetRadius = Math.ceil((Math.random() * 80));
			    var planetGeometry = new THREE.IcosahedronGeometry(planetRadius, 1);

                var planetMaterial = materials[Math.ceil(Math.random()*(materials.length-1))];

                //om materialet är faces, väljd då pieces, annars vanliga planet-geometryn.
                var geometry = (planetMaterial instanceof THREE.MeshFaceMaterial) ? geometry_pieces : planetGeometry;

                var planet = new THREE.Mesh(geometry, planetMaterial);

				planet.position.y = Math.floor(Math.random() * 200 - 100) * 15;
				planet.position.z = Math.floor(Math.random() * 200 - 100) * 15;
				planet.position.x = Math.floor(Math.random() * 200 - 100) * 10;

				planet.rotation.x = Math.random() * 200 - 100;
				planet.rotation.y = Math.random() * 200 - 100;
				planet.rotation.z = Math.random() * 200 - 100;
				
				objects.push(planet);
				
				scene.add(planet);
			}

			// Ladda in modell
			var jsonLoader = new THREE.JSONLoader();
	  	    jsonLoader.load( "./models/island1.js", addModelToScene );
	        // addModelToScene function is called back after model has loaded
	          
	        var ambientLight = new THREE.AmbientLight(0x111111);
	        scene.add(ambientLight);
	          

	        function addModelToScene( geometry, materials ) 
	        {
		        var material = new THREE.MeshFaceMaterial( materials );

		        for ( var i = 0; i < materials.length; i ++ ) {

					materials[i].shading = THREE.FlatShading;
				}

		        model = new THREE.Mesh( geometry, material );
		        model.scale.set(50,50,50);
		        scene.add( model );
	        }


			//Ett kub-objekt för att examplifiera animationen
			var cube_geometry = new THREE.BoxGeometry(10, 10, 10);
			var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
			cube = new THREE.Mesh( cube_geometry, material );
			scene.add(cube);

			//Sätter igång och loopar musiken
			//var music = new THREE.AudioObject('mys.mp3', 0, 1, true);
  			//scene.add(music);

  			//------LJUS------
  			var ambiColor = "#0c0c0c";
   			var ambientLight = new THREE.AmbientLight(ambiColor);

   			scene.add(ambientLight);

  			var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.125 );

			directionalLight.position.x = Math.random() * 400;
			directionalLight.position.y = Math.random() * 400;
			directionalLight.position.z = Math.random() * 400;

			directionalLight.position.normalize();

			scene.add( directionalLight );

			//stjärna som upplevs lysa
			particleLight = new THREE.Mesh( new THREE.SphereGeometry( 4, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
			scene.add( particleLight );

			//ljuset åt stjärnan
			pointLight = new THREE.PointLight( 0xffffff, 1 );
			scene.add( pointLight );
		}

		//Anävnder ramverket Tween för att animera
		function setupTween()
		{
			var update	= function(){
				cube.position.x = current.x;
			}
			var current	= { x: 0 };

			//Ta bort eventuella äldre tweens
			TWEEN.removeAll();

			//Sätter hur animationen ska se ut.
			var easing	= TWEEN.Easing.Sinusoidal.InOut;

			//Animation åt ena hållet
			var tweenHead	= new TWEEN.Tween(current)
			.to({x: 100}, 2000)
			.easing(easing)
			.onUpdate(update);

			//Animation åt andra hållet
			var tweenBack	= new TWEEN.Tween(current)
			.to({x: -100}, 2000)
			.easing(easing)
			.onUpdate(update);

			//Kedjar de båda animationerna
			tweenHead.chain(tweenBack);
			tweenBack.chain(tweenHead);

			tweenHead.start();
		}

		setup();
		animation();

		</script>
	</body>
</html>